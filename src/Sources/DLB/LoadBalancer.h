/***********************************************
*
*  File Name:       LoadBalancer.h
*
*  Project:         Dynamic Load Balancing in HPC Applications
*                   DIP (SC@FIT)
*                 
*  Description:     LoadBalancer class header file
*           
*  Author:          Vojtech Dvoracek
*  Email:           xdvora0y@stud.fit.vutbr.cz
*  Date:            10.4.2017
*
***********************************************/

#ifndef __LOAD_BALANCER_H__
#define __LOAD_BALANCER_H__

#include <zoltan_cpp.h>

#include <map>
#include <vector>
#include <cmath>
#include <list>
#include <algorithm>
#include <numeric>

#include <iomanip>


#include <Asserts.h>
#include <TileMsg.h>
#include <Dims.h>
#include <TileDescriptor.h>
#include <PerfMeasure.h>
#include <BlockData.h>

using std::vector;
using std::map;
using std::list;

namespace DLB {

/**
 * @brief Class providing main load balancing routines
 * 
 * @details This class works as load balancing wrapper.
 * 			At this moment, Zoltan is at the heart of it,
 * 			but may be changed to something else.
 * 
 */

class LoadBalancer
{

public:

	LoadBalancer(int rank, size_t edgeSize,  int worldSize, Dims objectSize, double threshold);
	~LoadBalancer(void);
	
	/**
	 * @brief 	Compute new decomposition based on actual state and 
	 * 			measured performance data.
	 * 
	 * @details [long description]
	 * 
	 * @param pm [description]
	 * @param tiles [description]
	 * 
	 * @return [description]
	 */
	vector<TileDescriptor> * getPartition(	const vector<double> & pm,
					  						const vector<TileDescriptor> & tiles
					  					);


	vector<unsigned> splitByPerform(const vector<double> & times);


	vector<TileDescriptor> * regularTiles(void);
	// vector<TileDescriptor> * groupByHostname(vector<TileDescriptor> * tls);

	/**
	 * @brief Migrate data between CPU using Zoltan_Migrate
	 * @details [long description]
	 * 
	 * @param b TempBlock instance with allocated memory
	 */

	// wrapper arround Zoltan_Migrate
	// data handling is performed via registered callbacks

	void migrateData(void);

	/**
	 * @brief Deallocates arrays with migration params
	 * @details [long description]
	 */

	void clearArrays(void);


	/**
	 * @brief Detects possible imbalance
	 * 
	 * @param times - measured performance
	 * 
	 * @return true if balanced
	 */

	bool isBalanced( vector<double> & times);

	// void setZoltanParts(const vector<float> & times);


	void check(double &x, bool max=false);


	// zoltan LB partition results
	// using Zoltan naming convention
	bool imbalance;
    int changed;
    int gid_entries, lid_entries;
    int num_import;
  
    ZOLTAN_ID_PTR import_global_ids, import_local_ids;
    ZOLTAN_ID_PTR export_global_ids, export_local_ids;
  
    int * import_procs;
    int * import_to_part;
    int * export_procs;
    int * export_to_part;
    int num_export;


	Zoltan *zz;
	MPI_Comm zoltComm;


protected:

	// usefull variables
	size_t edgeSize;
	int rank, worldSize;
	Dims objectSize;

	// cols and rows in regular mesh
	// generated by regularTiles()
	unsigned cols, rows;
	unsigned objCols, objRows;
	double threshold;



	






};


} //DLB nspace end


#endif